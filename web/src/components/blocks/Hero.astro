---
import ResponsiveImage from '../ResponsiveImage.astro';

interface ButtonProps {
  text: string;
  url: string;
  variant: 'primary' | 'secondary' | 'outline';
}

interface OverlaySettings {
  overlayType: 'radial' | 'linear' | 'solid' | 'none';
  overlayColor: string;
  overlayOpacity: number;
  secondaryColor: string;
  gradientDirection: string;
  radialPosition: string;
  shadowIntensity: 'soft' | 'medium' | 'strong' | 'none';
  secondaryOpacity: number;
}

interface HeroProps {
  mainTitle: string;
  subtitle: string;
  description: string;
  primaryButton: ButtonProps;
  secondaryButton: ButtonProps;
  backgroundImage: any;
  silhouetteImage: any;
  silhouettePosition: 'right' | 'left' | 'center';
  overlaySettings?: OverlaySettings;
}

const { 
  mainTitle, 
  subtitle, 
  description, 
  primaryButton, 
  secondaryButton, 
  backgroundImage, 
  silhouetteImage, 
  silhouettePosition = 'right',
  overlaySettings = {
    overlayType: 'radial',
    overlayColor: '#1e3a8a',
    overlayOpacity: 0.8,
    secondaryColor: '#000000',
    gradientDirection: 'to bottom',
    radialPosition: 'center',
    shadowIntensity: 'medium',
    secondaryOpacity: 0.8
  }
} = Astro.props;

// Función para obtener la clase de posición de la silueta
const getSilhouettePositionClass = (position: string) => {
  switch (position) {
    case 'left':
      return 'lg:order-first';
    case 'center':
      return 'lg:order-none';
    case 'right':
    default:
      return 'lg:order-last';
  }
};

// Función para generar el estilo del overlay
const getOverlayStyle = (settings: OverlaySettings) => {
  if (settings.overlayType === 'none') return '';
  
  const primaryOpacity = settings.overlayOpacity;
  const secondaryOpacity = settings.secondaryOpacity;
  const primaryColor = settings.overlayColor;
  const secondaryColor = settings.secondaryColor;
  
  // Función auxiliar para convertir color hex a rgb
  const hexToRgb = (hex: string) => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  };
  
  // Función para crear color rgba
  const createRgba = (color: string, opacity: number) => {
    if (color.startsWith('rgb')) {
      // Si ya es rgb, convertir a rgba
      return color.replace('rgb', 'rgba').replace(')', `, ${opacity})`);
    } else if (color.startsWith('#')) {
      // Si es hex, convertir a rgba
      const rgb = hexToRgb(color);
      if (rgb) {
        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
      }
    }
    // Si no se puede convertir, usar el color original
    return color;
  };
  
  switch (settings.overlayType) {
    case 'radial':
      return `background: radial-gradient(ellipse at ${settings.radialPosition}, ${createRgba(primaryColor, primaryOpacity)}, ${createRgba(secondaryColor, secondaryOpacity)});`;
    case 'linear':
      return `background: linear-gradient(${settings.gradientDirection}, ${createRgba(primaryColor, primaryOpacity)}, ${createRgba(secondaryColor, secondaryOpacity)});`;
    case 'solid':
      return `background: ${createRgba(primaryColor, primaryOpacity)};`;
    default:
      return '';
  }
};

// Función para obtener la intensidad de la sombra del texto
const getShadowClass = (intensity: string) => {
  switch (intensity) {
    case 'soft':
      return 'text-shadow-soft';
    case 'medium':
      return 'text-shadow-medium';
    case 'strong':
      return 'text-shadow-strong';
    case 'none':
    default:
      return '';
  }
};
---

<!-- Hero Section simplificado y optimizado -->
<section class="hero-section z-0 relative overflow-hidden">
  <!-- Fondo de imagen -->
  {backgroundImage && (
    <div class="hero-background will-change-transform">
      <ResponsiveImage
        image={backgroundImage}
        alt="Fondo del Hero"
        title="Fondo"
        class="hero-background-image"
        aspectRatio="auto"
        sizes="100vw"
      />
    </div>
  )}
  
  <!-- Silueta de fondo (solo en desktop) -->
  {silhouetteImage && (
    <div class="hero-silhouette hidden lg:block absolute inset-0 w-full h-full pointer-events-none z-30 will-change-transform">
      <div class={`absolute top-0 w-1/2 ${silhouettePosition === 'left' ? 'left-0' : 'right-0'} flex items-start justify-center`}>
        <div class="relative w-full flex items-start justify-center transform scale-125 origin-top">
          <ResponsiveImage
            image={silhouetteImage}
            alt="Silueta del Hero"
            title="Silueta"
            class="w-full h-auto object-contain"
            aspectRatio="auto"
          />
        </div>
      </div>
    </div>
  )}
  
  <!-- Overlay configurable -->
  {overlaySettings.overlayType !== 'none' && (
    <div 
      class="hero-overlay"
      style={getOverlayStyle(overlaySettings)}
    ></div>
  )}
  
  <!-- Contenido principal -->
  <div class="hero-content">
    <div class="w-full max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 lg:gap-16 items-center h-full">
        
        <!-- Columna de texto -->
        <div class="text-white space-y-6 z-40 text-center lg:text-left lg:col-span-2">
          <p class={`hero-main-title animate-fade-in-up ${getShadowClass(overlaySettings.shadowIntensity)}`}>{mainTitle}</p>
          <h1 class={`hero-subtitle animate-fade-in-up ${getShadowClass(overlaySettings.shadowIntensity)}`} style="animation-delay: 0.2s;">{subtitle}</h1>
          <p class={`hero-description animate-fade-in-up ${getShadowClass(overlaySettings.shadowIntensity)}`} style="animation-delay: 0.4s;">{description}</p>
          
          <div class="hero-buttons animate-fade-in-up justify-center lg:justify-start" style="animation-delay: 0.6s;">
            {primaryButton && (
              <sl-button 
                href={primaryButton.url}
                variant={primaryButton.variant === 'primary' ? 'primary' : primaryButton.variant === 'outline' ? 'outline' : 'neutral'}
                size="large"
                class="min-w-[180px]"
              >
                {primaryButton.text}
              </sl-button>
            )}
            
            {secondaryButton && (
              <sl-button 
                href={secondaryButton.url}
                variant={secondaryButton.variant === 'primary' ? 'primary' : secondaryButton.variant === 'outline' ? 'outline' : 'neutral'}
                size="large"
                class="min-w-[180px]"
              >
                {secondaryButton.text}
              </sl-button>
            )}
          </div>
        </div>
        
        <!-- Columna vacía para balance visual -->
        <div class="hidden lg:block"></div>
        
      </div>
    </div>
  </div>
</section>

<!-- Sentinel para comportamiento del header sticky -->
<div class="hero-sentinel" aria-hidden="true"></div>

<style>
  /* Animaciones simplificadas */
  .animate-fade-in-up {
    animation: fadeInUp 0.8s ease-out forwards;
    opacity: 0;
    transform: translateY(30px);
  }
  
  @keyframes fadeInUp {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  

  
  /* Responsive simplificado */
  @media (max-width: 640px) {
    .hero-main-title {
      font-size: 1.25rem !important;
      line-height: 1.3 !important;
    }
    
    .hero-subtitle {
      font-size: 2rem !important;
      line-height: 1.1 !important;
    }
    
    .hero-description {
      font-size: 1rem !important;
      line-height: 1.5 !important;
    }
    
    .hero-buttons {
      flex-direction: column !important;
      gap: 1rem !important;
    }
    
    .hero-buttons sl-button {
      width: 100% !important;
    }
  }
</style>

<script>
  if (typeof window !== 'undefined') {
    const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const section = (document.currentScript && typeof (document.currentScript as any).closest === 'function'
      ? (document.currentScript as any).closest('section')
      : document.querySelector('.hero-section'));
    const bg = section ? section.querySelector('.hero-background') : null;
    const sil = section ? section.querySelector('.hero-silhouette') : null;
    if (section && !reduceMotion) {
      let frame = 0;
      const onScroll = () => {
        if (frame) return;
        frame = requestAnimationFrame(() => {
          frame = 0;
          const top = (section as HTMLElement).offsetTop;
          const height = (section as HTMLElement).offsetHeight || 1;
          const y = window.scrollY || window.pageYOffset;
          const raw = (y - top + window.innerHeight) / (height + window.innerHeight);
          const progress = Math.max(0, Math.min(1, raw));
          const bgY = (-6 + 10 * progress).toFixed(2);
          const silY = (-2 + 4 * progress).toFixed(2);
          if (bg) (bg as HTMLElement).style.transform = `translateY(${bgY}vh)`;
          if (sil) (sil as HTMLElement).style.transform = `translateY(${silY}vh)`;
        });
      };
      onScroll();
      window.addEventListener('scroll', onScroll, { passive: true });
      window.addEventListener('resize', onScroll);
    }
  }
  </script>
